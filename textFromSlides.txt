Текст, который использовался на слайдах презентации.

Деструктурирующее присваивание – это специальный синтаксис, 
который позволяет нам «распаковать» массивы или объекты в кучу переменных, 
так как иногда они более удобны.

Хуки

1. Хуки - нововведение в React 16.8, которое позволяет использовать
состояние, методы жизненного цикла и другие возмоности React 
без написания классов.

2. Хуки - это обычные JavaScript функции.

3. У хуков есть всего два правила.

Первое правило хуков:

- Никому не рассказывать о хуках

Правило 1

- Хуки работают ТОЛЬКО внутри функциональных компонент React и
пользовательских хуков.

Следовательно,

- Вызывать хуки можно ТОЛЬКО из функционального компонента React и
пользовательских хуков.

Правило 2

- Вызывать хуки можно только на верхнем уровне.

Не используйте хуки внутри циклов, условных операторов или вложенных функций. 
Вместо этого всегда используйте хуки только на верхнем уровне React-функций. 
Исполнение этого правила гарантирует, что хуки вызываются в одинаковой 
последовательности при каждом рендере компонента.
Это позволит React правильно сохранять состояние хуков между множественными 
вызовами useState и useEffect. 

Если вы хотите использовать массив зависимостей, обратите внимание на то, 
чтобы массив включал в себя все значения из области видимости компонента 
(такие как пропсы и состояние), которые могут изменяться с течением времени, 
и которые будут использоваться эффектом. В противном случае, ваш код будет 
ссылаться на устаревшее значение из предыдущих рендеров. 

Если вы хотите запустить эффект и сбросить его только один раз 
(при монтировании и размонтировании), вы можете передать пустой массив [] 
вторым аргументом. React посчитает, что ваш эффект не зависит от каких-либо 
значений из пропсов или состояния и поэтому не будет выполнять 
повторных рендеров. Это не обрабатывается как особый случай — он напрямую 
следует из логики работы массивов зависимостей.

Если вы передадите пустой массив [], пропсы и состояние внутри эффекта 
всегда будут иметь значения, присвоенные им изначально. Хотя передача [] 
ближе по модели мышления к знакомым componentDidMount и componentWillUnmount, 
обычно есть более хорошие способы избежать частых повторных рендеров. 
Не забывайте, что React откладывает выполнение useEffect, пока браузер не 
отрисует все изменения, поэтому выполнение дополнительной работы не является 
существенной проблемой.

Рефакторинг

Рефакторинг — это контролируемый процесс улучшения кода, 
без написания новой функциональности. 

Результат рефакторинга — это чистый код и простой дизайн.
                                        
Тендеции
                           
Gatsby & Next 

Используя мощь современных фреймворков и таких 
инструментов как Webpack и продвинутый CSS, 
генераторы статических сайтов позволяют создавать 
прекрасные сайты с уникальным контентом, 
без особых усилий. Оба этих генератора для React 
являются лучшими в своем роде.

Gatsby.JS  - это генератор статических сайтов. 
Генератор статического сайта генерирует 
статический HTML во время сборки.
Он не использует сервер.


Next.JS - это в основном инструмент для рендеринга страниц 
на стороне сервера. Он динамически генерирует HTML каждый раз, 
когда поступает новый запрос с использованием сервера.

Конечно, оба могут вызывать API-интерфейсы на стороне клиента. П
ринципиальное отличие заключается в том, что Next требует, чтобы сервер мог работать. 
Gatsby может работать без какого-либо сервера вообще.

Gatsby генерирует чистый HTML/CSS/JS в build time, 
тогда как Next создает HTML/CSS/JS в run time. 
Таким образом, каждый раз, когда приходит новый запрос, 
он создает новую HTML-страницу с сервера.

Итоги

1. В классах много лишнего.
2. Невнимательность ломает код.
3. Хуки - не кусаються.
4. Знать классы - всеравно нужно.
5. Рефакторить старый код - не нужно.
6. Новые проекты - писать функционально.
7. Реакт - это только начало.